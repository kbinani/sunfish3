/* CodeGenerator.cpp
 * 
 * Kubo Ryosuke
 */

#if !defined(NDEBUG)

#include "CodeGenerator.h"
#include "core/util/Random.h"
#include "core/base/Piece.h"
#include "core/base/Square.h"
#include "core/board/Bitboard.h"
#include <iostream>

namespace sunfish {

namespace {

/**
 * 盤面の駒に対する乱数表を作成
 */
void generateZobristOnBoard(Random& random) {

  std::cout << "const uint64_t Zobrist::Board[Square::N][Piece::Num] = {\n";
  SQUARE_EACH(sq) {
    std::cout << "\t{\n";
    PIECE_EACH_UNSAFE(piece) {
      std::cout << "\t\t0x" << std::hex << random.getInt64() << "ll,\n";
    }
    std::cout << "\t},\n";
  }
  std::cout << "};\n";

}

/**
 * 持ち駒に対する乱数表を作成
 */
void generateZobristOnHand(Random& random, const char* pieceName, int num) {

  std::cout << "const uint64_t Zobrist::Hand" << pieceName << "[" << std::dec << num << "] = {\n";
  for (int i = 0; i < num; i++) {
    std::cout << "\t0x" << std::hex << random.getInt64() << "ll,\n";
  }
  std::cout << "};\n";

}

/**
 * 黒番にの時の乱数を作成
 */
void generateZobristBlack(Random& random) {

  std::cout << "const uint64_t Zobrist::Black = 0x" << std::hex << random.getInt64() << "ll;\n";

}

} // namespace

void CodeGenerator::generateZobrist() {
  std::cout << "/* Zobrist.cpp \n";
  std::cout << " * \n";
  std::cout << " * generated by CodeGenerator\n";
  std::cout << " */\n";
  std::cout << "\n";
  std::cout << "#include \"Zobrist.h\"";
  std::cout << "\n";
  std::cout << "namespace sunfish {\n";
  std::cout << "\n";

  Random random;

  generateZobristOnBoard(random);

  std::cout << "\n";

  generateZobristOnHand(random, "BPawn", 18);
  generateZobristOnHand(random, "BLance", 4);
  generateZobristOnHand(random, "BKnight", 4);
  generateZobristOnHand(random, "BSilver", 4);
  generateZobristOnHand(random, "BGold", 4);
  generateZobristOnHand(random, "BBishop", 2);
  generateZobristOnHand(random, "BRook", 2);

  generateZobristOnHand(random, "WPawn", 18);
  generateZobristOnHand(random, "WLance", 4);
  generateZobristOnHand(random, "WKnight", 4);
  generateZobristOnHand(random, "WSilver", 4);
  generateZobristOnHand(random, "WGold", 4);
  generateZobristOnHand(random, "WBishop", 2);
  generateZobristOnHand(random, "WRook", 2);

  generateZobristBlack(random);

  std::cout << "\n";
  std::cout << "} // namespace sunfish\n";
}

namespace {

using namespace sunfish;

void printBitboardTable(const char* name, const Bitboard* table, size_t size) {
  std::cout << "const Bitboard " << name << "[" << std::dec << size << "] = {\n";
  for (size_t i = 0; i < size; i++) {
    std::cout << "\tBitboard(0x" << std::hex << std::setw(16) << std::setfill('0') << table[i].high() << "ll,"
      " 0x" << std::hex << std::setw(16) << std::setfill('0') << table[i].low() << "ll),\n";
  }
  std::cout << "};\n";
}

template <size_t size2>
void printBitboardTable2D(const char* name, const Bitboard (*table)[size2], size_t size1) {
  std::cout << "const Bitboard " << name << "[" << std::dec << size1 << "][" << size2 << "] = {\n";
  for (size_t i = 0; i < size1; i++) {
    std::cout << "\t{\n";
    for (size_t j = 0; j < size2; j++) {
      std::cout << "\t\tBitboard(0x" << std::hex << std::setw(16) << std::setfill('0') << table[i][j].high() << "ll,"
        " 0x" << std::hex << std::setw(16) << std::setfill('0') << table[i][j].low() << "ll),\n";
    }
    std::cout << "\t},\n";
  }
  std::cout << "};\n";
}

#define GEN_MASK(dir, rdir, full) { \
SQUARE_EACH(from) { \
for (Square to = from; (full ? to : to.safety ## dir()).isValid(); to = to.safety ## dir()) { \
  if (full || to.safety ## rdir().isValid()) { \
    table[from.index()].set(to.index()); \
  } \
} \
} \
}

void generateDirectionMaskTable() {
  Bitboard table[Square::N];

  SQUARE_EACH(sq) { table[sq.index()].init(); }
  GEN_MASK(Up, Down, true);
  printBitboardTable("DirectionMaskTable::up_", table, Square::N);

  SQUARE_EACH(sq) { table[sq.index()].init(); }
  GEN_MASK(Down, Up, true);
  printBitboardTable("DirectionMaskTable::down_", table, Square::N);

  SQUARE_EACH(sq) { table[sq.index()].init(); }
  GEN_MASK(Left, Right, true);
  printBitboardTable("DirectionMaskTable::left_", table, Square::N);

  SQUARE_EACH(sq) { table[sq.index()].init(); }
  GEN_MASK(Right, Left, true);
  printBitboardTable("DirectionMaskTable::right_", table, Square::N);

  SQUARE_EACH(sq) { table[sq.index()].init(); }
  GEN_MASK(LeftUp, RightDown, true);
  printBitboardTable("DirectionMaskTable::leftUp_", table, Square::N);

  SQUARE_EACH(sq) { table[sq.index()].init(); }
  GEN_MASK(RightDown, LeftUp, true);
  printBitboardTable("DirectionMaskTable::rightDown_", table, Square::N);

  SQUARE_EACH(sq) { table[sq.index()].init(); }
  GEN_MASK(RightUp, LeftDown, true);
  printBitboardTable("DirectionMaskTable::rightUp_", table, Square::N);

  SQUARE_EACH(sq) { table[sq.index()].init(); }
  GEN_MASK(LeftDown, RightUp, true);
  printBitboardTable("DirectionMaskTable::leftDown_", table, Square::N);

  SQUARE_EACH(sq) { table[sq.index()].init(); }
  GEN_MASK(Left, Right, false);
  GEN_MASK(Right, Left, false);
  printBitboardTable("DirectionMaskTable7x7::rank_", table, Square::N);

  SQUARE_EACH(sq) { table[sq.index()].init(); }
  GEN_MASK(LeftUp, RightDown, false);
  GEN_MASK(RightDown, LeftUp, false);
  printBitboardTable("DirectionMaskTable7x7::leftUpX_", table, Square::N);

  SQUARE_EACH(sq) { table[sq.index()].init(); }
  GEN_MASK(RightUp, LeftDown, false);
  GEN_MASK(LeftDown, RightUp, false);
  printBitboardTable("DirectionMaskTable7x7::rightUpX_", table, Square::N);
}

#undef GEN_MASK

bool isFileEnabled(int file, Square baseSq, Direction dir) {
  if (dir == Direction::Left || dir == Direction::Right) {
    return true;
  } else if (dir == Direction::LeftUp || dir == Direction::RightDown) {
    int minFile = std::max(2, baseSq.getFile() + baseSq.getRank() - 8);
    int maxFile = std::min(8, baseSq.getFile() + baseSq.getRank() - 2);
    return file >= minFile && file <= maxFile;
  } else if (dir == Direction::LeftDown || dir == Direction::RightUp) {
    int minFile = std::max(2, baseSq.getFile() - baseSq.getRank() + 2);
    int maxFile = std::min(8, baseSq.getFile() - baseSq.getRank() + 8);
    return file >= minFile && file <= maxFile;
  } else {
    assert(false);
  }
}

int file2BitIndex(bool useBmi2, int file, Square baseSq, Direction dir) {
  int list[7] = { 2, 8, 7, 6, 5, 4, 3 };

  if (useBmi2) {
    int index = 0;
    for (int i = 0; i < 7; i++) {
      if (list[i] == file) {
        return index;
      } else if (isFileEnabled(list[i], baseSq, dir)) {
        index++;
      }
    }
  } else {
    int index = 6;
    for (int i = 6; i >= 0; i--) {
      if (list[i] == file) {
        return index;
      } else if (isFileEnabled(list[i], baseSq, dir)) {
        index--;
      }
    }
  }
  assert(false);
}

void generateMagicNumberTable() {
  auto set = [](Square sq, Square baseSq, uint64_t& magicLow, uint64_t& magicHigh, Direction dir) {
    int index = file2BitIndex(false, sq.getFile(), baseSq, dir);
    if (Bitboard::isLow(sq)) {
      magicLow |= 1ULL << (64 - 7 + index - sq.index());
    } else {
      magicHigh |= 1ULL << (64 - 7 + index - (sq.index() - Bitboard::LowBits));
    }
  };

  std::cout << "#if !USE_BMI2\n";
  std::cout << "const Bitboard MagicNumberTable::leftUp_[Square::N] = {\n";
  SQUARE_EACH(baseSq) {
    {
      uint64_t magicLow = 0ULL;
      uint64_t magicHigh = 0ULL;
      for (Square sq = baseSq.safetyLeftUp(); sq.safetyLeftUp().isValid(); sq = sq.safetyLeftUp()) {
        set(sq, baseSq, magicLow, magicHigh, Direction::LeftUp);
      }
      for (Square sq = baseSq.safetyRightDown(); sq.safetyRightDown().isValid(); sq = sq.safetyRightDown()) {
        set(sq, baseSq, magicLow, magicHigh, Direction::LeftUp);
      }
      if (baseSq.safetyLeftUp().isValid() && baseSq.safetyRightDown().isValid()) {
        set(baseSq, baseSq, magicLow, magicHigh, Direction::LeftUp);
      }

      std::cout << "\tBitboard(0x" << std::hex << std::setw(16) << std::setfill('0') << magicHigh << "ll,"
        " 0x" << std::hex << std::setw(16) << std::setfill('0') << magicLow << "ll),\n";
    }
  }
  std::cout << "};\n";

  std::cout << "const Bitboard MagicNumberTable::rightUp_[Square::N] = {\n";
  SQUARE_EACH(baseSq) {
    {
      uint64_t magicLow = 0ULL;
      uint64_t magicHigh = 0ULL;
      for (Square sq = baseSq.safetyRightUp(); sq.safetyRightUp().isValid(); sq = sq.safetyRightUp()) {
        set(sq, baseSq, magicLow, magicHigh, Direction::RightUp);
      }
      for (Square sq = baseSq.safetyLeftDown(); sq.safetyLeftDown().isValid(); sq = sq.safetyLeftDown()) {
        set(sq, baseSq, magicLow, magicHigh, Direction::RightUp);
      }
      if (baseSq.safetyRightUp().isValid() && baseSq.safetyLeftDown().isValid()) {
        set(baseSq, baseSq, magicLow, magicHigh, Direction::RightUp);
      }

      std::cout << "\tBitboard(0x" << std::hex << std::setw(16) << std::setfill('0') << magicHigh << "ll,"
        " 0x" << std::hex << std::setw(16) << std::setfill('0') << magicLow << "ll),\n";
    }
  }
  std::cout << "};\n";

  Bitboard rank_[Square::RankN];
  for (int rank = 1; rank <= 9; rank++) {
    uint64_t magicLow = 0ULL;
    uint64_t magicHigh = 0ULL;
    for (int file = 2; file <= 8; file++) {
      Square sq(file, rank);
      set(sq, sq, magicLow, magicHigh, Direction::Right);
    }
    rank_[rank-1] = Bitboard(magicHigh, magicLow);
  }
  std::cout << "const Bitboard MagicNumberTable::rank_[Square::N] = {\n";
  SQUARE_EACH(sq) {
    std::cout << "\tBitboard(0x" << std::hex << std::setw(16) << std::setfill('0') << rank_[sq.getRank()-1].high() << "ll,"
      " 0x" << std::hex << std::setw(16) << std::setfill('0') << rank_[sq.getRank()-1].low() << "ll),\n";
  }
  std::cout << "};\n";
  std::cout << "#endif\n";
}

void generateMovePatternTable(bool useBmi2) {
  Bitboard up_[Square::N][0x80];
  Bitboard down_[Square::N][0x80];
  Bitboard file_[Square::N][0x80];
  Bitboard rank_[Square::N][0x80];
  Bitboard leftUpX_[Square::N][0x80];
  Bitboard rightUpX_[Square::N][0x80];
  Bitboard leftUp_[Square::N][0x80];
  Bitboard leftDown_[Square::N][0x80];
  Bitboard rightUp_[Square::N][0x80];
  Bitboard rightDown_[Square::N][0x80];
  Bitboard left_[Square::N][0x80];
  Bitboard right_[Square::N][0x80];

  SQUARE_EACH(sq) {
    for (unsigned i = 0; i < 0x80; i++) {
      up_[sq.index()][i].init();
      down_[sq.index()][i].init();
      file_[sq.index()][i].init();
      rank_[sq.index()][i].init();
      leftUpX_[sq.index()][i].init();
      rightUpX_[sq.index()][i].init();
      leftUp_[sq.index()][i].init();
      leftDown_[sq.index()][i].init();
      rightUp_[sq.index()][i].init();
      rightDown_[sq.index()][i].init();
      left_[sq.index()][i].init();
      right_[sq.index()][i].init();
    }
  }

  SQUARE_EACH(baseSq) {
    for (unsigned b = 0; b < 0x80; b++) {
      // up
      for (Square sq = baseSq.safetyUp(); sq.isValid() && sq.getRank() >= 1; sq = sq.safetyUp()) {
        up_[baseSq.index()][b].set(sq);
        file_[baseSq.index()][b].set(sq);
        if (b & (1 << (sq.getRank() - 2))) { break; }
      }
      // down
      for (Square sq = baseSq.safetyDown(); sq.isValid() && sq.getRank() <= 9; sq = sq.safetyDown()) {
        down_[baseSq.index()][b].set(sq);
        file_[baseSq.index()][b].set(sq);
        if (b & (1 << (sq.getRank() - 2))) { break; }
      }
      // left
      for (Square sq = baseSq.safetyLeft(); sq.isValid(); sq = sq.safetyLeft()) {
        rank_[baseSq.index()][b].set(sq);
        left_[baseSq.index()][b].set(sq);
        if (sq.getFile() == 9) { break; }
        if (b & (1 << file2BitIndex(useBmi2, sq.getFile(), baseSq, Direction::Left))) { break; }
      }
      // right
      for (Square sq = baseSq.safetyRight(); sq.isValid(); sq = sq.safetyRight()) {
        rank_[baseSq.index()][b].set(sq);
        right_[baseSq.index()][b].set(sq);
        if (sq.getFile() == 1) { break; }
        if (b & (1 << file2BitIndex(useBmi2, sq.getFile(), baseSq, Direction::Right))) { break; }
      }
      // left-up
      for (Square sq = baseSq.safetyLeftUp(); sq.isValid(); sq = sq.safetyLeftUp()) {
        leftUpX_[baseSq.index()][b].set(sq);
        leftUp_[baseSq.index()][b].set(sq);
        if (sq.getFile() == 9) { break; }
        if (b & (1 << file2BitIndex(useBmi2, sq.getFile(), baseSq, Direction::LeftUp))) { break; }
      }
      // right-down
      for (Square sq = baseSq.safetyRightDown(); sq.isValid(); sq = sq.safetyRightDown()) {
        leftUpX_[baseSq.index()][b].set(sq);
        rightDown_[baseSq.index()][b].set(sq);
        if (sq.getFile() == 1) { break; }
        if (b & (1 << file2BitIndex(useBmi2, sq.getFile(), baseSq, Direction::RightDown))) { break; }
      }
      // right-up
      for (Square sq = baseSq.safetyRightUp(); sq.isValid(); sq = sq.safetyRightUp()) {
        rightUpX_[baseSq.index()][b].set(sq);
        rightUp_[baseSq.index()][b].set(sq);
        if (sq.getFile() == 1) { break; }
        if (b & (1 << file2BitIndex(useBmi2, sq.getFile(), baseSq, Direction::RightUp))) { break; }
      }
      // left-down
      for (Square sq = baseSq.safetyLeftDown(); sq.isValid(); sq = sq.safetyLeftDown()) {
        rightUpX_[baseSq.index()][b].set(sq);
        leftDown_[baseSq.index()][b].set(sq);
        if (sq.getFile() == 9) { break; }
        if (b & (1 << file2BitIndex(useBmi2, sq.getFile(), baseSq, Direction::LeftDown))) { break; }
      }
    }
  }
  printBitboardTable2D<0x80>("MovePatternTable::up_", up_, Square::N);
  printBitboardTable2D<0x80>("MovePatternTable::down_",down_ , Square::N);
  printBitboardTable2D<0x80>("MovePatternTable::file_", file_, Square::N);
  printBitboardTable2D<0x80>("MovePatternTable::rank_", rank_, Square::N);
  printBitboardTable2D<0x80>("MovePatternTable::leftUpX_", leftUpX_, Square::N);
  printBitboardTable2D<0x80>("MovePatternTable::rightUpX_", rightUpX_, Square::N);
  printBitboardTable2D<0x80>("MovePatternTable::leftUp_", leftUp_, Square::N);
  printBitboardTable2D<0x80>("MovePatternTable::leftDown_", leftDown_, Square::N);
  printBitboardTable2D<0x80>("MovePatternTable::rightUp_", rightUp_, Square::N);
  printBitboardTable2D<0x80>("MovePatternTable::rightDown_", rightDown_, Square::N);
  printBitboardTable2D<0x80>("MovePatternTable::left_", left_, Square::N);
  printBitboardTable2D<0x80>("MovePatternTable::right_", right_, Square::N);
}

void generateMovePatternTable() {
  std::cout << "#if USE_BMI2\n";
  generateMovePatternTable(true);
  std::cout << "#else\n";
  generateMovePatternTable(false);
  std::cout << "#endif\n";
}

void generateOneStepMoveTable(const char* name, Piece type) {
  std::cout << "const Bitboard " << name << "[Square::N] = {\n";
  SQUARE_EACH(sq) {
    Bitboard bb;
    bb.init();
    switch (type.index()) {
    case Piece::BPawn:
      bb |= Bitboard(sq.safetyUp());
      break;
    case Piece::BKnight:
      bb |= Bitboard(sq.safetyUp(2).safetyLeft());
      bb |= Bitboard(sq.safetyUp(2).safetyRight());
      break;
    case Piece::BSilver:
      bb |= Bitboard(sq.safetyUp().safetyLeft());
      bb |= Bitboard(sq.safetyUp());
      bb |= Bitboard(sq.safetyUp().safetyRight());
      bb |= Bitboard(sq.safetyDown().safetyLeft());
      bb |= Bitboard(sq.safetyDown().safetyRight());
      break;
    case Piece::BGold:
      bb |= Bitboard(sq.safetyUp().safetyLeft());
      bb |= Bitboard(sq.safetyUp());
      bb |= Bitboard(sq.safetyUp().safetyRight());
      bb |= Bitboard(sq.safetyLeft());
      bb |= Bitboard(sq.safetyRight());
      bb |= Bitboard(sq.safetyDown());
      break;
    case Piece::WPawn:
      bb |= Bitboard(sq.safetyDown());
      break;
    case Piece::WKnight:
      bb |= Bitboard(sq.safetyDown(2).safetyLeft());
      bb |= Bitboard(sq.safetyDown(2).safetyRight());
      break;
    case Piece::WSilver:
      bb |= Bitboard(sq.safetyDown().safetyLeft());
      bb |= Bitboard(sq.safetyDown());
      bb |= Bitboard(sq.safetyDown().safetyRight());
      bb |= Bitboard(sq.safetyUp().safetyLeft());
      bb |= Bitboard(sq.safetyUp().safetyRight());
      break;
    case Piece::WGold:
      bb |= Bitboard(sq.safetyDown().safetyLeft());
      bb |= Bitboard(sq.safetyDown());
      bb |= Bitboard(sq.safetyDown().safetyRight());
      bb |= Bitboard(sq.safetyLeft());
      bb |= Bitboard(sq.safetyRight());
      bb |= Bitboard(sq.safetyUp());
      break;
    case Piece::Bishop:
    case Piece::Dragon:
      bb |= Bitboard(sq.safetyUp().safetyLeft());
      bb |= Bitboard(sq.safetyUp().safetyRight());
      bb |= Bitboard(sq.safetyDown().safetyLeft());
      bb |= Bitboard(sq.safetyDown().safetyRight());
      break;
    case Piece::Rook:
    case Piece::Horse:
      bb |= Bitboard(sq.safetyUp());
      bb |= Bitboard(sq.safetyLeft());
      bb |= Bitboard(sq.safetyRight());
      bb |= Bitboard(sq.safetyDown());
      break;
    case Piece::King:
      bb |= Bitboard(sq.safetyUp().safetyLeft());
      bb |= Bitboard(sq.safetyUp());
      bb |= Bitboard(sq.safetyUp().safetyRight());
      bb |= Bitboard(sq.safetyLeft());
      bb |= Bitboard(sq.safetyRight());
      bb |= Bitboard(sq.safetyDown().safetyLeft());
      bb |= Bitboard(sq.safetyDown());
      bb |= Bitboard(sq.safetyDown().safetyRight());
      break;
    default:
      assert(false);
    }
    std::cout << "\tBitboard(0x" << std::hex << std::setw(16) << std::setfill('0') << bb.high() << "ll,"
      " 0x" << std::hex << std::setw(16) << std::setfill('0') << bb.low() << "ll),\n";
  }
  std::cout << "};\n";
}

void generateOneStepMoveTable() {
 generateOneStepMoveTable("MoveTables::bpawn_", Piece::BPawn);
 generateOneStepMoveTable("MoveTables::bknight_", Piece::BKnight);
 generateOneStepMoveTable("MoveTables::bsilver_", Piece::BSilver);
 generateOneStepMoveTable("MoveTables::bgold_", Piece::BGold);
 generateOneStepMoveTable("MoveTables::wpawn_", Piece::WPawn);
 generateOneStepMoveTable("MoveTables::wknight_", Piece::WKnight);
 generateOneStepMoveTable("MoveTables::wsilver_", Piece::WSilver);
 generateOneStepMoveTable("MoveTables::wgold_", Piece::WGold);
 generateOneStepMoveTable("MoveTables::bishop1_", Piece::Bishop);
 generateOneStepMoveTable("MoveTables::rook1_", Piece::Rook);
 generateOneStepMoveTable("MoveTables::king_", Piece::King);
 generateOneStepMoveTable("MoveTables::horseOneStepMove_", Piece::Horse);
 generateOneStepMoveTable("MoveTables::dragonOneStepMove_", Piece::Dragon);
}

} // namespace

void CodeGenerator::generateMoveTable() {
  std::cout << "/* MoveTable.cpp \n";
  std::cout << " * \n";
  std::cout << " * generated by CodeGenerator\n";
  std::cout << " */\n";
  std::cout << "\n";
  std::cout << "#include \"MoveTable.h\"";
  std::cout << "\n";
  std::cout << "namespace sunfish {\n";
  std::cout << "\n";
  std::cout << "const DirectionMaskTable dirMask;\n";
  std::cout << "const DirectionMaskTable7x7 dirMask7x7;\n";
  std::cout << "#if !USE_BMI2\n";
  std::cout << "const MagicNumberTable magic;\n";
  std::cout << "#endif\n";
  std::cout << "const MovePatternTable movePattern;\n";
  std::cout << "\n";

  generateDirectionMaskTable();
  generateMagicNumberTable();
  generateMovePatternTable();
  generateOneStepMoveTable();

  std::cout << "\n";
  std::cout << "} // namespace sunfish\n";
}

} // namespace sunfish

#endif // !defined(NDEBUG)
